# Memory Renderer Design

## Overview

The Memory renderer is the simplest renderer in the k8s-manifest-kit ecosystem. It provides programmatic rendering of pre-constructed Kubernetes objects that are already in memory, with no file I/O, no templates, and no overlays.

## Architecture

### Core Components

1. **Renderer** (`pkg/mem.go`)
   - Main entry point implementing `types.Renderer`
   - Deep copies input objects to prevent mutations
   - Applies filters and transformers
   - Thread-safe for concurrent operations

2. **Source** (`pkg/mem.go`)
   - Contains pre-constructed `unstructured.Unstructured` objects
   - No dynamic values (objects are already constructed)
   - Minimal configuration

3. **Options** (`pkg/mem_option.go`)
   - Functional options pattern for renderer configuration
   - Supports filters, transformers, source annotations
   - No caching option (not needed for in-memory objects)

4. **Engine Convenience** (`pkg/engine.go`)
   - `NewEngine()` function for simple single-source scenarios
   - Wraps renderer creation with engine setup

## Key Design Decisions

### 1. Deep Copying

All objects are deep copied before processing:
- Prevents external code from modifying rendered objects
- Ensures isolation between renders
- Protects against accidental mutations

```go
for _, obj := range holder.Objects {
    objCopy := obj.DeepCopy()
    // ... process objCopy
}
```

### 2. No Caching

Unlike other renderers, mem renderer has no caching:
- Objects are already in memory (no expensive I/O)
- Deep copying is fast enough
- Simpler architecture without cache complexity

### 3. Minimal Source Annotations

When enabled, only adds source type:
- `k8s-manifest-kit.io/source.type`: `"mem"`
- No source.path (objects aren't from files)
- No source.file (objects aren't from files)

### 4. Simple Validation

Validation only checks:
- Objects have non-nil internal data
- No filesystem or path validation needed
- Fails fast on invalid objects

### 5. Thread Safety

Designed for concurrent use:
- Immutable configuration after creation
- Deep copies prevent shared mutable state
- No external I/O to synchronize
- Simplest thread safety model

## Error Handling

Follows Go error wrapping conventions:

```go
// Validation errors
fmt.Errorf("invalid source at index %d: %w", i, err)

// Empty object errors
fmt.Errorf("%w at index %d", ErrObjectEmpty, i)

// Pipeline errors
fmt.Errorf("error applying filters/transformers in mem renderer: %w", err)
```

**Specific error types:**
- `ErrObjectEmpty`: Object has nil or empty internal data

## Comparison with Other Renderers

### Memory vs. YAML

| Feature | Memory Renderer | YAML Renderer |
|---------|----------------|---------------|
| Input | In-memory objects | Files on disk |
| I/O | None | File reading |
| Caching | Not needed | Path-based |
| Complexity | Minimal | Low |

### Memory vs. Kustomize

| Feature | Memory Renderer | Kustomize Renderer |
|---------|----------------|-------------------|
| Input | In-memory objects | Kustomization |
| Processing | Pass-through | Overlays/patches |
| ConfigMaps | Pre-constructed | Generated |
| Complexity | Minimal | Medium-High |

### Memory vs. Helm

| Feature | Memory Renderer | Helm Renderer |
|---------|----------------|---------------|
| Input | In-memory objects | Chart packages |
| Templates | None | Go templates |
| Values | Pre-resolved | Dynamic injection |
| Complexity | Minimal | High |

## Use Cases

### Best For:
- **Testing**: Pass known objects without file fixtures
- **Composition**: Combine objects from multiple sources
- **Programmatic generation**: Objects created dynamically
- **Mocking**: Simulate renderer behavior
- **CI/CD**: Objects generated by previous pipeline steps
- **Unit tests**: Fast, no I/O overhead

### Not Suitable For:
- Loading from files (use YAML renderer)
- Template processing (use GoTemplate or Helm)
- Kustomize overlays (use Kustomize renderer)
- When source tracking to files is needed

## Performance Characteristics

### Time Complexity
- Deep copying: O(n) where n = total size of objects
- No I/O operations
- No parsing or template evaluation

### Memory Usage
- Objects duplicated (deep copy)
- No caching overhead
- Minimal memory beyond object storage

### Optimization Strategies
1. Reuse renderer instances (configuration is immutable)
2. Filter objects before passing to renderer
3. Split large object sets across multiple sources if needed
4. Consider pointer sharing for truly immutable objects (advanced)

## Testing Strategy

### Unit Tests
All tests use in-memory objects:
```go
pod := &corev1.Pod{...}
unstrPod, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(pod)
renderer, _ := mem.New([]mem.Source{{Objects: []unstructured.Unstructured{{Object: unstrPod}}}})
```

### Integration Tests
Test with engine:
```go
e, _ := mem.NewEngine(mem.Source{Objects: objects})
results, _ := e.Render(ctx)
```

### Benchmarks
Focus on:
- Deep copy overhead
- Filter/transformer performance
- Scaling with object count

## Future Enhancements

Potential improvements (not currently implemented):
- Lazy deep copying (copy-on-write)
- Parallel deep copying for large object sets
- Optional shallow copying for immutable objects
- Memory pooling for frequent small renders

## Related Documentation

- [Development Guide](development.md) - How to work with the codebase
- [CLAUDE.md](../CLAUDE.md) - AI assistant reference
- [Engine Documentation](https://github.com/k8s-manifest-kit/engine) - Core engine patterns

